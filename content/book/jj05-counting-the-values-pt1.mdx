[Count von Count](https://www.youtube.com/watch?v=eSukMy8DyfY) was my childhood role model. If you’re not familiar with him from Sesame Street, his favorite pastime is counting things. Today, Count von Count will join us in counting every value in the JavaScript universe.

You might wonder: what’s the point of *counting* values? We’re not in an arithmetics class, are we? The essence of counting is to distinguish things from one another. You can only say there are “two apples” when you clearly see that they’re two *distinct* apples. Distinguishing values from one another is key to understanding *equality* in JavaScript — which will be our next topic.

Count von Count will act as our guide as we travel through the “celestial spheres” of JavaScript to meet different values. We'll meet the primitive values: booleans, Numbers, Strings, and so on. We'll also meet objects and functions. Consider it a sightseeing tour.

![celestial spheres of javascript values](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1581381920/just-javascript-email-images/jj04/celestialspheres-v2.png)

## Counting the Values

### Undefined

We’ll start our tour with the Undefined type. Count von Count will be pleased to know that **there is only one value of that type — `undefined`**.

```js
console.log(typeof(undefined)); // "undefined"
```

![illustration of a black, spikey undefined icon next to a big black hole](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1580435620/just-javascript-email-images/jj04/undefined-revised.png)

It’s called undefined so you might think it’s not there — but it *is* a value, and a very real one! Like a black hole, `undefined` is grumpy and can often spell trouble. For example, reading a property from it will break your program:

```js
let person = undefined;
console.log(person.mood); // TypeError!
```

Oh, well. Luckily, there is only one `undefined` in the entire JavaScript universe. You might wonder: why does it exist at all? In JavaScript, it represents the concept of an *unintentionally* missing value.

You could use it in your own code by writing `undefined` — like you write `2` or `"hello"`. However, `undefined` *also* commonly “occurs naturally”. It shows up in some situations where JavaScript doesn’t know what value you wanted. For example, if you forget to assign a variable, it will point to `undefined`:

```js
let bandersnatch;
console.log(bandersnatch); // undefined
```
![diagram of the variable bandersnatch attached to the undefined visual icon](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1580435620/just-javascript-email-images/jj04/undefined-example.png)

Then you can point it to another value, or to `undefined` again if you want.

Don’t get too hung up on its name. It’s tempting to think of `undefined` as some kind of variable status, e.g. “this variable is not yet defined”. But that’s a completely misleading way to think about it! In fact, if you read a variable that was *actually* not defined (or before the `let` declaration), you will get an error:

```js
console.log(jabberwocky); // ReferenceError!
let jabberwocky;
```

That has nothing to do with undefined.

Really, `undefined` is a regular primitive value, like `2` or `"hello"`.

Handle it with care.

### Null

![illustration of a grey null circle, and a large barren null planet](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1580435620/just-javascript-email-images/jj04/null-revised.png)

You can think of `null` as `undefined`’s sister. It behaves very similarly. For example, it will also throw a fuss when you try to access its properties:

```js
let mimsy = null;
console.log(mimsy.mood); // TypeError!
```

![diagram showing the variable mimsy attached to the visual icon for null](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1580435620/just-javascript-email-images/jj04/null-example.png)

Similarly to `undefined`, **`null` is the only value of its own type**. However, `null` is also a liar. Due to a [bug](https://2ality.com/2013/10/typeof-null.html) in JavaScript, it pretends to be an object:

```js
console.log(typeof(null)); // "object" (a lie!)
```

You might think this means `null` is an object. Don’t fall into this trap! It is a primitive value, and it doesn’t behave in any way like an object. Unfortunately, `typeof(null)` is a historical accident that we’ll have to live with forever.

In practice, `null` is used for *intentionally* missing values. Why have both `null` and `undefined`? This could help you distinguish a coding mistake (which might result in `undefined`) from valid missing data (which you might express as `null`). However, this is only a convention, and JavaScript doesn’t enforce this usage. Some people avoid both of them as much as possible!

I don’t blame them.

### Booleans

![Booleans](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1580435620/just-javascript-email-images/jj04/boolean-revised.png)

Like day and night, **there are only two boolean values: `true` and `false`.**

```js
console.log(typeof(true)); // "boolean"
console.log(typeof(false)); // "boolean"
```

We can perform logical operations with them:

```js
let isSad = true;
let isHappy = !isSad; // The opposite
let isFeeling = isSad || isHappy; // Is at least one of them true?
let isConfusing = isSad && isHappy; // Are both true?
```

Count von Count would like to check your mental model now. Open a [sketching app](https://www.excalidraw.com/) or take a piece of paper, and sketch out the variables, the values, and the wires between them for the above snippet of code.

<SpoilerAlert alertTitle="Spoilers Below" alertBody="Don’t scroll further until you have finished sketching." />

...

...

...

...

...

...

...

...

...

...


Check your answer against this picture:

![Booleans](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1580435620/just-javascript-email-images/jj04/boolean-example.png)

First, verify that `isHappy` points to `false`, `isFeeling` points to `true`, and `isConfusing` points to `false`. (If you got different answers, there is a mistake somewhere along the way — walk through each line step by step.)

Next, verify that **there is only one `true` and one `false` value on your sketch**. Count von Count insists that this is important! Regardless of how booleans are stored in the memory, *in our mental model* there are only two of them.

### Numbers

![Numbers](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1580773430/just-javascript-email-images/jj04/numbers-v2.png)

So far, we counted exactly four values: `null`, `undefined`, `true`, and `false`.

Hold on, as we will add eighteen quintillion, four hundred and thirty-seven quadrillion, seven hundred and thirty-six trillion, eight hundred and seventy-four billion, four hundred and fifty-four million, eight hundred and twelve thousand, six hundred and twenty-four more values to our mental model!

I am, of course, talking about numbers:

```js
console.log(typeof(28)); // "number"
console.log(typeof(3.14)); // "number"
console.log(typeof(-140)); // "number"
```

At first, numbers might seem unremarkable. Let’s look closer!

#### A Math for Computers

JavaScript numbers don’t behave exactly the same way as regular mathematical numbers do. Here is a snippet that demonstrates it:

```js
console.log(0.1 + 0.2 === 0.3); // false
console.log(0.1 + 0.2 === 0.30000000000000004); // true
```

This might look very surprising! Contrary to a popular belief, this doesn’t mean that JavaScript numbers are broken. This behavior is common in different programming languages. It even has a name: *floating point math*.

You see, JavaScript doesn’t implement the kind of math we use in real life. Floating point math is “math for computers”. Don’t worry too much about this name or how it works exactly. Very few people know about all its subtleties, and that’s the point! It works well enough in practice that most of the time you won’t think about it. Still, let’s take a quick look at what makes it different.

#### Colors and Numbers

Have you ever used a scanner to turn a physical photo or a document into a digital one? This analogy can help us understanding JavaScript numbers.

Scanners usually distinguish at most 16 million colors. If you draw a picture with a red crayon and scan it, the scanned image should come out red too — but it will have the *closest* red color our scanner picked from those 16 million colors. So if you have two red crayons with ever so slightly different colors, the scanner might be fooled into thinking their color is exactly the same!

*We can say that a scanner treats colors as having a limited precision.*

Floating point math is similar. In real math, there is an infinite set of numbers. But in floating point math, **there are only 18 quintillion of them.** So when we write numbers in our code or do calculations with them, JavaScript picks the *closest* numbers that it knows about — just like our scanner does with colors.

*In other words, JavaScript treats numbers as having a limited precision.*

We can imagine all of the JavaScript numbers on an axis. The closer we are to `0`, the more precision numbers have, and the closer they “sit” to each other:

![number line](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1580435620/just-javascript-email-images/jj04/number_axis.gif)

As we move from `0` in either direction, we start losing precision. At some point, even two closest JavaScript numbers stay further apart than by `1`:

```js
console.log(Number.MAX_SAFE_INTEGER);     // 9007199254740991
console.log(Number.MAX_SAFE_INTEGER + 1); // 9007199254740992
console.log(Number.MAX_SAFE_INTEGER + 2); // 9007199254740992
console.log(Number.MAX_SAFE_INTEGER + 3); // 9007199254740994
console.log(Number.MAX_SAFE_INTEGER + 4); // 9007199254740996
console.log(Number.MAX_SAFE_INTEGER + 5); // 9007199254740996
```

Luckily, any **whole** numbers between `Number.MIN_SAFE_INTEGER` and `Number.MAX_SAFE_INTEGER` are exact. This is why `10 + 20 === 30`.

But when we write `0.1` or `0.2`, we don’t get *exactly* `0.1` and `0.2`. We get the closest available numbers in JavaScript. They are almost exactly the same, but there might be a tiny difference. These tiny differences add up, which is why `0.1 + 0.2` doesn’t give us *exactly* the same number as writing `0.3`.

If this is still confusing, don’t worry. You can [learn more about floating point math](https://floating-point-gui.de/formats/fp/), but you already know more than I did when I started writing this guide! Unless you work on finance apps, you likely won’t need to worry about this.

#### Special Numbers

It is worth noting that floating point math includes a few *special numbers*. You might occasionally run into `NaN`, `Infinity`, `-Infinity`, and `-0`. They exist because sometimes you might execute operations like `1 / 0`, and JavaScript needs to represent their result somehow. The floating point math standard specifies how they work, and what happens when you use them.

Here’s how special numbers may come up in your code:

```js
let scale = 0;
let a = 1 / scale; // Infinity
let b = 0 / scale; // NaN
let c = -a; // -Infinity
let d = 1 / c; // -0
```

Out of these special numbers, `NaN` is particularly interesting. `NaN`, which is the result of `0 / 0` and some other invalid math, stands for “not a number”.

You might be confused by why it claims to be a number:

```js
console.log(typeof(NaN)); // "number"
```

However, there is no trick here. From JavaScript perspective, `NaN` *is* a numeric value. It is not null, undefined, a string, or some other type. But in the floating point math, the *name* for that term is [“not a number”](https://en.wikipedia.org/wiki/NaN). So it *is* a numeric value. It happens to be called “not a number” because it represents an invalid result.

It’s uncommon to write code using these special numbers. However, they might come up due to a coding mistake. So it’s good to know they exist.

### BigInts

![big ints](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1580773481/just-javascript-email-images/jj05/bigints-v2.png)

BigInts were only recently added to JavaScript, so you won’t see them used widely yet. If you use an older browser, they won’t work. Regular numbers can’t represent large integers with precision, so BigInts [fill that gap](https://v8.dev/features/bigint) (literally):

```js
let alot = 9007199254740991n; // Notice n at the end
console.log(alot + 1n); // 9007199254740992n
console.log(alot + 2n); // 9007199254740993n
console.log(alot + 3n); // 9007199254740994n
console.log(alot + 4n); // 9007199254740995n
console.log(alot + 5n); // 9007199254740996n
```

No funny business with the rounding! This is great for financial calculations where precision is especially important. Keep in mind that nothing is free. Operations with *truly* huge numbers may take time and resources.

How many BigInts are there in our universe? The specification says they have an *arbitrary precision*. This means that **in our JavaScript universe, there is an infinite number of BigInts — one for each integer in math**.

Yeah...

If this sounds strange, consider that you’re already comfortable with the idea of there being infinite integers in math. (If you’re not, give it a few moments!) It’s not much of a leap then from a “math universe” to a “JavaScript universe”.

*(And from there, we can go straight to the [Pepsi Universe](https://www.goldennumber.net/wp-content/uploads/pepsi-arnell-021109.pdf).)*

Of course, in practice, we can’t fit all the possible BigInts inside the computer memory. If we tried, at some point it would crash or freeze. But conceptually, Count von Count could be busy counting BigInts for eternity and never stop.

### Strings

![Illustration of strings](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1580773483/just-javascript-email-images/jj05/strings-v2.png)

Strings represent text in JavaScript. There are three ways to write strings (single quotes, double quotes, and backticks), but the result is the same:

```js
console.log(typeof("こんにちは")); // "string"
console.log(typeof('こんにちは')); // "string"
console.log(typeof(`こんにちは`)); // "string"
```

An empty string is a string, too:

```js
console.log(typeof('')); // "string"
```

#### Strings Aren’t Objects

All strings have a few built-in properties.

```js
let cat = 'Cheshire';
console.log(cat.length); // 8
console.log(cat[0]); // "C"
console.log(cat[1]); // "h"
```

This doesn’t mean that strings are objects! String properties are special and don’t behave the way object properties do. For example, you can’t assign anything to `cat[0]`. Strings are primitives, and all primitives are immutable.

#### A Value for Every Conceivable String

**In our universe, there is a distinct value for every conceivable string.** Yes, this includes your grandmother’s maiden name, the fanfic you published ten years ago under an alias, and the script of Matrix 5 which hasn’t been written yet.

Of course, all possible strings can’t literally fit inside a computer memory chip. But *the idea* of every possible string can fit inside your head. Our JavaScript universe is a model for humans, not for computers!

This might prompt a question. Does this code *create* a string?

```js
// Try it in your console
let answer = prompt('Enter your name');
console.log(answer); // ?
```

Or does it merely *summon* a string that already exists in our universe?

The answer to this question depends on whether we’re studying JavaScript “from the outside” or “from the inside”.

*Outside* our mental model, the answer depends on a specific implementation. Whether a string is represented as a single block of memory, multiple blocks, or [a rope](https://en.wikipedia.org/wiki/Rope_(data_structure)), is up to the JavaScript engine.

But *inside* our mental model, this question doesn’t mean anything. We can’t set up an experiment to say whether strings “get created” or “get summoned” within our JavaScript universe.

To keep our mental model simple, we will say that **all conceivable string values already exist from the beginning — one value for every distinct string.**

### Symbols

Symbols are a relatively recent addition to the language.

```js
let alohomora = Symbol();
console.log(typeof(alohomora)); // "symbol"
```

It’s hard to explain their purpose and behavior without diving deeper into objects and properties, and they are relatively rare, so in our universe, we're going to skip them. Sorry, symbols!


## To Be Continued

This module is split in two parts. We’ve reached the end of the Part 1. We’ll take a small break now. Let’s recap the primitive values we’ve counted so far!

![Primitive values: null, undefined, booleans, numbers, BigInts, Strings & Symbols](https://res.cloudinary.com/dg3gyk0gu/image/upload/v1581382060/just-javascript-email-images/jj04/primitives-pt1-v3.png)

* **Undefined**: Only one value, `undefined`.
* **Null**: Only one value, `null`.
* **Booleans**: Two values: `true` and `false`.
* **Numbers**: One value for each floating point math number.
* **BigInts**: One value for every conceivable integer.
* **Strings**: One value for every conceivable string.

We’ve also learned a few interesting facts about JavaScript numbers:

* **Not all numbers can be perfectly represented in JavaScript.** Their decimal part offers more precision closer to `0`, and less precision further away from it. We can say that their decimal point is “floating”.
* **Numbers from invalid math operations like `1 / 0` or `0 / 0` are special.** `NaN` is one of such numbers. They may appear due to coding mistakes.
* **`typeof(NaN)` is a number because `NaN` is a numeric value.** It’s called “Not a Number” because it represents the *idea* of an "invalid" number.

In the second part, we will continue our sightseeing tour. Specifically, we will look at Objects and Functions and try to count them all.

## Exercises

This module also has exercises for you to practice!

[**Click here** to solidify this mental model with a few short exercises.](https://eggheadio.typeform.com/to/C3Ajk4?email={{subscriber.email_address}}) When you complete the exercises I will send Part 2.

**Don’t skip them!**

Even though you’re probably familiar with different types of values, these exercises will help you cement the mental model we’re building. This foundation will help as you explore increasingly complex topics.
